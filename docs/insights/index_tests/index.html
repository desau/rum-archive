<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="/css/main.css" />
  <script src="/js/main.js"></script>
  <title>RUM Archive - RUM Insights PREVIEW TEST</title>
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#006a80">
  <meta name="msapplication-TileColor" content="#006a80">
  <meta name="theme-color" content="#006a80">

  <!-- Facebook Meta Tags -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="RUM Archive - RUM Insights PREVIEW TEST">
  <meta property="og:image" content="https://rumarchive.com/assets/rum-archive-banner-facebook-1200x630.png">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta property="twitter:domain" content="rumarchive.com">
  <meta name="twitter:title" content="RUM Archive - RUM Insights PREVIEW TEST">
  <meta name="twitter:image" content="https://rumarchive.com/assets/rum-archive-banner-twitter-1600x900.png">

  <link rel="feed alternate" type="application/atom+xml" href="/blog/feed.xml" title="Atom Feed">

  <script>(function(){if(window.BOOMR&&(window.BOOMR.version||window.BOOMR.snippetExecuted)){return}window.BOOMR=window.BOOMR||{};window.BOOMR.snippetStart=(new Date).getTime();window.BOOMR.snippetExecuted=true;window.BOOMR.snippetVersion=15;window.BOOMR.url="//c.go-mpulse.net/boomerang/S4RHZ-UABWM-G9DGN-GKRY7-DUGEG";var e=document.currentScript||document.getElementsByTagName("script")[0],a=e.parentNode,s=false,t=3e3;function n(){if(s){return}var e=document.createElement("script");e.id="boomr-scr-as";e.src=window.BOOMR.url;e.async=true;a.appendChild(e);s=true}function i(e){s=true;var t,i=document,n,o,d,r=window;window.BOOMR.snippetMethod=e?"if":"i";n=function(e,t){var n=i.createElement("script");n.id=t||"boomr-if-as";n.src=window.BOOMR.url;BOOMR_lstart=(new Date).getTime();e=e||i.body;e.appendChild(n)};if(!window.addEventListener&&window.attachEvent&&navigator.userAgent.match(/MSIE [678]\./)){window.BOOMR.snippetMethod="s";n(a,"boomr-async");return}o=document.createElement("IFRAME");o.src="about:blank";o.title="";o.role="presentation";o.loading="eager";d=(o.frameElement||o).style;d.width=0;d.height=0;d.border=0;d.display="none";a.appendChild(o);try{r=o.contentWindow;i=r.document.open()}catch(e){t=document.domain;o.src="javascript:var d=document.open();d.domain='"+t+"';void 0;";r=o.contentWindow;i=r.document.open()}r._boomrl=function(){n()};if(r.addEventListener){r.addEventListener("load",r._boomrl,false)}else if(r.attachEvent){r.attachEvent("onload",r._boomrl)}i.close()}var o=document.createElement("link");if(o.relList&&typeof o.relList.supports==="function"&&o.relList.supports("preload")&&"as"in o){window.BOOMR.snippetMethod="p";o.href=window.BOOMR.url;o.rel="preload";o.as="script";o.addEventListener("load",n);o.addEventListener("error",function(){i(true)});setTimeout(function(){if(!s){i(true)}},t);BOOMR_lstart=(new Date).getTime();a.appendChild(o)}else{i(false)}function d(e){window.BOOMR_onload=e&&e.timeStamp||(new Date).getTime()}if(window.addEventListener){window.addEventListener("load",d,false)}else if(window.attachEvent){window.attachEvent("onload",d)}})();</script>
</head>
<body>
  <header><nav class="navbar is-light" role="navigation" aria-label="main navigation">
  <div class="navbar-brand">
    <a class="navbar-item" href="/">
      <img src="/assets/rum-archive-logo-square.svg" width="28" height="28" />
    </a>

    <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false" data-target="navbar-main">
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
    </a>
  </div>

  <div id="navbar-main" class="navbar-menu">
    <div class="navbar-start">
      <div class="navbar-item has-text-weight-bold">
        <a href="/">RUM Archive</a>
      </div>
    </div>

    <div class="navbar-end">
      <div class="navbar-item has-dropdown is-hoverable">
        <a class="navbar-link" href="/docs/">
          Documentation
        </a>

        <div class="navbar-dropdown">
          <a class="navbar-item" href="/docs/methodology">
            Methodology
          </a>
          <a class="navbar-item" href="/docs/querying">
            Querying
          </a>
          <a class="navbar-item" href="/docs/tables">
            Tables
          </a>
          <a class="navbar-item" href="/docs/samples">
            Samples
          </a>
          <a class="navbar-item" href="/docs/tips">
            Tips
          </a>
          <a class="navbar-item" href="/docs/release-notes">
            Release  Notes
          </a>
        </div>
      </div>

      <a href="/datasets" class="navbar-item">
        Datasets
      </a>

      <a href="/blog" class="navbar-item">
        Blog
      </a>

      <a href="/insights" class="navbar-item">
        Insights
      </a>

      <a href="/contribute" class="navbar-item">
        Contribute!
      </a>

      <a href="https://github.com/rum-archive/rum-archive" class="navbar-item">
        Github
      </a>

      <a href="/about" class="navbar-item">
        About
      </a>
    </div>
  </div>
</nav>
</header>
  <main>
    
<article class="page-layout">
  <div class="container">
    <div class="columns">
      <div class="column is-10 is-offset-1">
        <div class="content m-5">
          <h1>RUM Insights PREVIEW TEST</h1>
          
          
<h2>Introduction</h2>

<p>
This page captures a collection of basic visualizations for the data contained in the RUM Archive. 
It's goal is to allow users to get a feel for the most important insights that can be gained from the data, without having to execute SQL queries themselves.
</p>

<p>
Note that we intentionally do not include interpretations of the data here, as this can often be quite nuanced. For that, look at our <a href="/blog">regular blog posts</a> that discuss RUM Insights in depth. 
</p>


<!-- TODO: merge these into a single file --> 
<script src="/js/highcharts/highstock.js" defer></script>
<script src="/js/highcharts/exporting.js" defer></script>
<script src="/js/highcharts/export-data.js" defer></script>
<script src="/js/highcharts/accessibility.js" defer></script>

<section class="doclist mt-3 pt-3">
    
  

  

    <div class="container">
      <div class="columns is-centered">
        <div class="column is-half control" style="text-align: center; vertical-align: middle;">
          <!-- <label class="label" for="marketshare_browser_version_select">Select browser:</label> -->
          <div class="select">
            <select id="userAgentSelect">
            </select>
          </div>
        </div>
      </div>
      <div id="ua_version" class="box">
      </div>
    </div>  

    <h2>Web Features Baseline Overview</h2>

    We count the percentage of page loads included in the RUM Archive on the first Tuesday of March 2024.

    <style>
      .table.is-hoverable tbody tr:not(.is-selected):hover {
        cursor: pointer;
      }
    </style>

    <div class="container">
      <div id="baseline_desktop" class="box">
        <h3>Baseline support Desktop</h3>
        <div class="columns">
          <div class="column is-one-third">
            <table id="baseline_desktop_table" class="table is-hoverable">
              <thead>
                <tr>
                  <th>Baseline year</th>
                  <th>Supported by % of users</th>
                </tr>
              </thead>
              <tbody>
                
              </tbody>
            </table>
          </div>
          <div id="baseline_desktop_details" class="column is-two-thirds">
            <h4>Details</h4>
            <div>Click on a row in the table to get more information per Baseline year</div>
          </div>
        </div>

      </div>

      <div id="baseline_mobile" class="box">
        <h3>Baseline support Mobile</h3>
        <div class="columns">
          <div class="column is-one-third">
            <table id="baseline_mobile_table" class="table is-hoverable">
              <thead>
                <tr>
                  <th>Baseline year</th>
                  <th>Supported by % of users</th>
                </tr>
              </thead>
              <tbody>
                
              </tbody>
            </table>
          </div>
          <div id="baseline_mobile_details" class="column is-two-thirds">
            <h4>Details</h4>
            <div>Click on a row in the table to get more information per Baseline year</div>
          </div>
        </div>
      </div>
    </div>

</section>

<script type="module">

    import { Constants } from "/js/charts/constants.js";
    import * as TimeSeries from "/js/charts/timeseries.js"; 
    import * as Donuts from "/js/charts/donuts.js";
    import * as Area from "/js/charts/area.js";

    // 3 colors with good contrast, since we often have piecharts with exactly 2 or 3 entries
    const piecolors = [ TimeSeries.Colors.RUMARCHIVE_MAIN[0], TimeSeries.Colors.RUMARCHIVE_MAIN[1], TimeSeries.Colors.RUMARCHIVE_SECONDARY[5] ];

    const FORCE_EXTERNAL_DATA = false;
    let DATA_BASE_URL = "https://raw.githubusercontent.com/rum-archive/rum-insights-data/main/data-output/";

    if ( window.location.href.includes("localhost") && !FORCE_EXTERNAL_DATA ) {
      // allow for easy local testing
      // launch a basic python http server in the rum-insights-data dir with `python3 -m http.server 9000`
      DATA_BASE_URL = "http://localhost:9000/data-output/";
    }

    
    // returns e.g., "2023_12_01"
    function findLastDate(dataPoints) {
      // want to find the most recent datapoint in the file
      // for now, we don't actually parse the dates, but just assume the final entry in the list of dataPoints is part of the most recent batch
      if ( dataPoints && dataPoints.length > 0 && dataPoints[ dataPoints.length - 1].date ) {
        return dataPoints[ dataPoints.length - 1].date;
      }
      else {
        console.error("findLastDate: no 'date' property found on dataPoints, defaulting to 2023_12_01!", dataPoints);
        return "2024_03_05";
      }
    }

    


    let GLOBAL_selectedUserAgent = "";

    async function loadUserAgentSelectOptions() {

      let response = await fetch(DATA_BASE_URL + "useragentversion_useragentfamily_devicetype.json");
      let rumarchiveData = await response.json();
    
      // need to extract the unique useragentfamily_devicetype values
      let useragents = new Set();
      for( let row of rumarchiveData ) {
        useragents.add( row.client + "_" + row.family );
      }

      useragents = Array.from( useragents ).sort();

      const selectBox = document.getElementById("userAgentSelect");
      for ( let useragent of useragents ) {
        const option = document.createElement("option");
        const split = useragent.split("_");
        option.text = split[0] + " : " + split[1];
        option.value = useragent;
        selectBox.add(option);
      }

      selectBox.addEventListener("change", (event) => {
        GLOBAL_selectedUserAgent = event.target.value;
        TimeSeries.fromDataWithDefaults( "useragentversion_useragentfamily_devicetype", "ua_version", "version", GLOBAL_selectedUserAgent.split("_")[1] + " Versions", getUserAgentTimeSeries );
      });

      // load the default (first entry in the list)
      GLOBAL_selectedUserAgent =  rumarchiveData[0].client + "_" + rumarchiveData[0].family;
      TimeSeries.fromDataWithDefaults( "useragentversion_useragentfamily_devicetype", "ua_version", "version", rumarchiveData[0].family + " Versions", getUserAgentTimeSeries );

    }

    loadUserAgentSelectOptions();

    function getUserAgentTimeSeries(rumarchiveData, metricFieldName) {
      const [deviceType, useragentFamily] = GLOBAL_selectedUserAgent.split("_");
      rumarchiveData = rumarchiveData.filter( datapoint => (parseFloat(datapoint.percent) > 1) );
      rumarchiveData = rumarchiveData.filter( datapoint => datapoint.family === useragentFamily && datapoint.client === deviceType );

      console.log("Showing user agent ", GLOBAL_selectedUserAgent, rumarchiveData);

      let output = [];

      // need to give the graphing setup a list of timeseries, each with their own data and color
      // we want to generate these automatically from the data
      // 1. extract individual metricFieldValues (e.g., extract all individual device types)
      let metricValues = new Set();
      for ( let row of rumarchiveData )
        metricValues.add( row[metricFieldName] );

      for ( const [idx, metricValue] of [...metricValues].entries() ) {
        let timeSerie = {
          name: metricValue,
          data: rumarchiveData.filter( o => o[metricFieldName] === metricValue ),
          fields: ["percent"],
          color: TimeSeries.Colors.LIST[idx]
        };

        output.push( timeSerie );
      }

      return output;
    }


    async function populateBaselineInfo() {

      let ua_data_raw = await fetch(DATA_BASE_URL + "recent_useragentversion_useragentfamily_devicetype.json");
      let ua_data  = await ua_data_raw.json();

      let web_features_raw = await fetch(DATA_BASE_URL + "web-features.json"); 
      let web_features  = await web_features_raw.json();

      console.log( ua_data, web_features );

      /*
      // determine what's actually in the dataset
      let uasInFeatures = new Set();

      for( let web_feature of Object.values(web_features) ) {
        if ( web_feature && web_feature.status && web_feature.status.support && Object.keys(web_feature.status.support).length > 0 ) {
          for ( let platform of Object.keys(web_feature.status.support) ){
            uasInFeatures.add( platform );
          }
        }
      } 

      console.log( uasInFeatures );
      */

      // we want to create a baseline list for desktop vs mobile (which is what web-features gives us)
      // web-features is limited to:
      // Desktop: chrome, edge, firefox, safari
      // Mobile: chrome_android, firefox_android, safari_ios
      
      // so we filter out the accompanying ones from the RUM-archive for now
      let desktopUAs = ["Chrome", "Edge", "Firefox", "Safari"];
      let mobileUAs = ["Firefox Mobile", "Chrome Mobile", "Chrome Mobile WebView", "Mobile Safari", "Mobile Safari UI/WKWebView" ];

      // map from RUMArchive names to web-features names
      let desktopUAMappings = {
        "Chrome": "chrome",
        "Edge": "edge",
        "Firefox": "firefox",
        "Safari": "safari",
      };

      let mobileUAMappings = {
        "Chrome Mobile": "chrome_android",
        "Chrome Mobile WebView": "chrome_android",
        "Mobile Safari": "safari_ios",
        "Mobile Safari UI/WKWebView": "safari_ios",
        "Firefox Mobile": "firefox_android",
      };

      // to calculate percentages, need to know total beacon counts per platform for a given day
      let totalDesktopCount = 0;
      let totalMobileCount = 0;
      for( let datapoint of ua_data ){
        if ( desktopUAs.includes(datapoint.family) && datapoint.client === "desktop" ) {
          totalDesktopCount += datapoint.count;
        }
        else if ( mobileUAs.includes(datapoint.family) && datapoint.client === "mobile" ) {
          totalMobileCount += datapoint.count;
        }
      }

      // console.log( totalDesktopCount, totalMobileCount );

      // 1. per year, we need a list of features that were added to the baseline in that year with links (that's easy though)
      // 2. per year, we need a total COUNT of how many beacons belong to browsers whose version were >= versions that started to support that feature

      // 1.
      let baselineResults = [
        { client: "desktop", uas: desktopUAs, uamappings: desktopUAMappings, totalCount: totalDesktopCount, yearCounts: [] },
        { client: "mobile", uas: mobileUAs, uamappings: mobileUAMappings, totalCount: totalMobileCount, yearCounts: [] },
      ];

      let baselineFeaturesPerYear = {};
      for( let year = 2015; year <= 2024; year++ ) {
        let yearFeatures = [];
        // baseline dates are for the baseline_low_date (means low availability, but year is correct)
        for ( let web_feature of Object.values(web_features) ) {
          if ( web_feature.status && web_feature.status.baseline_low_date ) {
            let featureYear = web_feature.status.baseline_low_date.split("-")[0]; // format: 2023-05-09
            if ( featureYear === ("" + year) ){
              yearFeatures.push( web_feature );
            }
          }
          else if( web_feature.status && web_feature.status.baseline !== false ) {
            console.warn("SANITY CHECK: web feature doesn't have baseline_low_date yet!", web_feature);
          }
          else if ( !web_feature.status ) {
            // console.error("SANITY CHECK: web feature doesn't have status yet!", web_feature);
            // APPARENTLY there are a great many features without a status yet... just skip them for now 
          }
        }

        baselineFeaturesPerYear["" + year] = yearFeatures;
      }

      console.log( "Baseline features per year:", baselineFeaturesPerYear );

      // 2.
      for( let baselineEntry of baselineResults ) {
        const client = baselineEntry.client;
        const uas = baselineEntry.uas;
        const uamappings = baselineEntry.uamappings;
        const resultsPerYear = baselineEntry.yearCounts;

        for( let year = 2015; year <= 2024; year++ ){

          if ( !resultsPerYear[""+year] ) {
            resultsPerYear[""+year] = 0;
          }

          const featuresForCurrentYear = baselineFeaturesPerYear["" + year];

          // for now, we just need a running total count of beacons that we saw that are >= a given version, don't really need to keep detailed results
          // so we just loop over each version for each browser for each client type, and for each check if it's >= the year's expected versions for each webFeature

          for( let datapoint of ua_data ){
            if ( datapoint.client === client && uas.includes(datapoint.family) ) {
              let version = datapoint.version;

              // for a given browser version entry, we need to see for ALL baseline features in that year if it's supported
              // this because e.g., a browser version could have gone live in July 202x but the baseline feature was only completed in the baseline in November 202x
              // We could theoretically also get this from the full baseline_low_date, but then we'd also need to know the release dates of all browser versions, which we don't :)
              // so: just check if we pass the version check for all of the webFeatures and only then add it to the resultsPerYear

              let passesAll = true; // assume yes

              for( let webFeature of featuresForCurrentYear ) {
                
                if( !webFeature.status ) {
                  console.error("SANITY CHECK: NO STATUS KNOWN, WHY NOT?!?", webFeature);
                }

                let webFeatureUAVersion = webFeature.status.support[ uamappings[datapoint.family] ];
                if ( webFeatureUAVersion ) {
                    // parseInt on e.g., "16.7" rounds down to 16, which is what we generally want :) 
                    // this only matters for Safari; others increment their full version, but safari has decimal subversions
                    // But RUM Archive doesn't track Safari's subversions currently, so rounding down is the best approach here
                    let baselineVersionInt = parseInt(webFeatureUAVersion, 10);
                    let rumArchiveVersionInt = parseInt(datapoint.version, 10);

                    if ( rumArchiveVersionInt < baselineVersionInt ) {  
                      console.warn("Feature was too new!", year, uamappings[datapoint.family], rumArchiveVersionInt, "<", baselineVersionInt, webFeature.name, (parseInt(datapoint.count) / baselineEntry.totalCount ) * 100 );
                      passesAll = false;
                      break; // we already know we failed, so we can do an early exit 
                    }
                }
                else {
                  console.error("SANITY CHECK: current ua not known in web-features...", datapoint.family, uamappings[datapoint.family], webFeature.status.support );
                }
              }

              if ( passesAll ) {
                resultsPerYear["" + year] += parseInt(datapoint.count); 
              }
            }
          }
        }
      }

      for( let baselineResult of baselineResults ) {
        console.log("For ", baselineResult.client );

        let outputTable = document.getElementById("baseline_"+ baselineResult.client +"_table").getElementsByTagName('tbody')[0];

        for ( let year of Object.keys(baselineResult.yearCounts) ) {
          let counts = baselineResult.yearCounts[year];
          let percentage = ((counts/baselineResult.totalCount) * 100).toFixed(2);

          console.log(year, counts, "out of", baselineResult.totalCount, "=", percentage );

          let yearRow = outputTable.insertRow();
          yearRow.setAttribute("baseline-year", year + "_" + percentage);
          // let yearCell = yearRow.insertCell(0);

          let yearCell = document.createElement("th");
          yearRow.appendChild(yearCell);
          let resultCell = yearRow.insertCell(1);

          yearCell.innerHTML = "" + year;
          resultCell.innerHTML = "" + percentage + "%";
        }

        outputTable.addEventListener("click", (evt) => {
          if ( !evt.target )
            return;

          // the click is usually the year <th> or the percentage <td>
          // we need to get parent tr if that's the case
          let row = evt.target;
          let yearPercent = evt.target.getAttribute("baseline-year");

          if ( !yearPercent && evt.target.parentNode ){
            yearPercent = evt.target.parentNode.getAttribute("baseline-year");
            row = evt.target.parentNode;
          }

          if ( !yearPercent ) // can't find the baseline-year... nothing left to do
            return;
          
          // make sure old element is deselected
          const currentlySelected = outputTable.getElementsByClassName("is-selected");
          for ( let cs of currentlySelected ) {
            cs.classList.remove("is-selected");
          }

          // select current row
          row.classList.add("is-selected");
          
          const year = yearPercent.split("_")[0];
          const percentage = yearPercent.split("_")[1];

          let detailsContainer = document.getElementById("baseline_"+ baselineResult.client +"_details");
          detailsContainer.getElementsByTagName("h4")[0].textContent = "Details for Baseline " + year;

          console.log("DEBUG");

          let detailsContent = "If you target the following Web features for "+year+"'s Baseline, <b>" + percentage + "%</b> of "+ baselineResult.client +" users in the RUM Archive would benefit:<br /><br />";

          // we want to group compat features by type (CSS, JS, HTML, API, Other)
          let groups = {
            "api": new Set(),
            "css": new Set(),
            "javascript": new Set(),
            "html": new Set(),
            "http": new Set(),
            "svg": new Set(),
            "other": new Set(),
          };

          for ( let feature of baselineFeaturesPerYear[year] ) {
            console.log("feature", feature);

            let compat_features = feature.compat_features;
            if( compat_features ){
              for ( let compat_feature of compat_features ){ 
                let prefix = compat_feature.split(".")[0]; // e.g., of the form 'html.elements.script.nomodule', 'javascript.statements.export'
                
                if( !groups[prefix] ) {
                  console.error("SANITY CHECK: feature group not yet known! skipping...", prefix, feature);
                  continue;
                }

                groups[prefix].add( feature );
              }
            }
            else {
              // e.g., AVIF support dosn't have compat_features
              groups["other"].add( feature );
            }
          }

          console.log( groups );

          for ( let group of Object.entries(groups) ) {
            if( group[1].size === 0 )
              continue;

            detailsContent += "<h5>" + group[0] + "</h5>";

            for ( let feature of group[1] ) {

              // some feature's name is a valid HTML element tag... LOOKING AT YOU <detail>... urgh
              let name = feature.name.replaceAll('<', '&lt;').replaceAll('>', '&gt;');

              detailsContent += "<p><a href=\"https://caniuse.com/"+ feature.caniuse +"\" target=\"_blank\">" + name + "</a></p>";
            }
          }

          let textContainer = detailsContainer.getElementsByTagName("div")[0];
          textContainer.innerHTML = detailsContent;
        });
      }

      console.log( baselineResults );
    }

    populateBaselineInfo();


</script>

        </div>
      </div>
    </div>
  </div>
</article>

  </main>
  <footer class="footer">
    <div class="content has-text-centered">
      <p>
        Sponsored by <a href="https://akamai.com">Akamai</a>.
        The website content is licensed
        <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>.
      </p>
      <p>
        <a href="https://twitter.com/RUMArchive">twitter</a> -
        <a rel="me" href="https://webperf.social/@rumarchive">mastodon</a>
      </p>
    </div>
  </footer>
</body>
</html>
