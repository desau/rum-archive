<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="/css/main.css" />
  <script src="/js/main.js"></script>
  <title>RUM Archive - RUM Insights PREVIEW TEST</title>
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#006a80">
  <meta name="msapplication-TileColor" content="#006a80">
  <meta name="theme-color" content="#006a80">

  <!-- Facebook Meta Tags -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="RUM Archive - RUM Insights PREVIEW TEST">
  <meta property="og:image" content="https://rumarchive.com/assets/rum-archive-banner-facebook-1200x630.png">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta property="twitter:domain" content="rumarchive.com">
  <meta name="twitter:title" content="RUM Archive - RUM Insights PREVIEW TEST">
  <meta name="twitter:image" content="https://rumarchive.com/assets/rum-archive-banner-twitter-1600x900.png">

  <link rel="feed alternate" type="application/atom+xml" href="/blog/feed.xml" title="Atom Feed">

  <script>(function(){if(window.BOOMR&&(window.BOOMR.version||window.BOOMR.snippetExecuted)){return}window.BOOMR=window.BOOMR||{};window.BOOMR.snippetStart=(new Date).getTime();window.BOOMR.snippetExecuted=true;window.BOOMR.snippetVersion=15;window.BOOMR.url="//c.go-mpulse.net/boomerang/S4RHZ-UABWM-G9DGN-GKRY7-DUGEG";var e=document.currentScript||document.getElementsByTagName("script")[0],a=e.parentNode,s=false,t=3e3;function n(){if(s){return}var e=document.createElement("script");e.id="boomr-scr-as";e.src=window.BOOMR.url;e.async=true;a.appendChild(e);s=true}function i(e){s=true;var t,i=document,n,o,d,r=window;window.BOOMR.snippetMethod=e?"if":"i";n=function(e,t){var n=i.createElement("script");n.id=t||"boomr-if-as";n.src=window.BOOMR.url;BOOMR_lstart=(new Date).getTime();e=e||i.body;e.appendChild(n)};if(!window.addEventListener&&window.attachEvent&&navigator.userAgent.match(/MSIE [678]\./)){window.BOOMR.snippetMethod="s";n(a,"boomr-async");return}o=document.createElement("IFRAME");o.src="about:blank";o.title="";o.role="presentation";o.loading="eager";d=(o.frameElement||o).style;d.width=0;d.height=0;d.border=0;d.display="none";a.appendChild(o);try{r=o.contentWindow;i=r.document.open()}catch(e){t=document.domain;o.src="javascript:var d=document.open();d.domain='"+t+"';void 0;";r=o.contentWindow;i=r.document.open()}r._boomrl=function(){n()};if(r.addEventListener){r.addEventListener("load",r._boomrl,false)}else if(r.attachEvent){r.attachEvent("onload",r._boomrl)}i.close()}var o=document.createElement("link");if(o.relList&&typeof o.relList.supports==="function"&&o.relList.supports("preload")&&"as"in o){window.BOOMR.snippetMethod="p";o.href=window.BOOMR.url;o.rel="preload";o.as="script";o.addEventListener("load",n);o.addEventListener("error",function(){i(true)});setTimeout(function(){if(!s){i(true)}},t);BOOMR_lstart=(new Date).getTime();a.appendChild(o)}else{i(false)}function d(e){window.BOOMR_onload=e&&e.timeStamp||(new Date).getTime()}if(window.addEventListener){window.addEventListener("load",d,false)}else if(window.attachEvent){window.attachEvent("onload",d)}})();</script>
</head>
<body>
  <header><nav class="navbar is-light" role="navigation" aria-label="main navigation">
  <div class="navbar-brand">
    <a class="navbar-item" href="/">
      <img src="/assets/rum-archive-logo-square.svg" width="28" height="28" />
    </a>

    <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false" data-target="navbar-main">
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
    </a>
  </div>

  <div id="navbar-main" class="navbar-menu">
    <div class="navbar-start">
      <div class="navbar-item has-text-weight-bold">
        <a href="/">RUM Archive</a>
      </div>
    </div>

    <div class="navbar-end">
      <div class="navbar-item has-dropdown is-hoverable">
        <a class="navbar-link" href="/docs/">
          Documentation
        </a>

        <div class="navbar-dropdown">
          <a class="navbar-item" href="/docs/methodology">
            Methodology
          </a>
          <a class="navbar-item" href="/docs/querying">
            Querying
          </a>
          <a class="navbar-item" href="/docs/tables">
            Tables
          </a>
          <a class="navbar-item" href="/docs/samples">
            Samples
          </a>
          <a class="navbar-item" href="/docs/tips">
            Tips
          </a>
          <a class="navbar-item" href="/docs/release-notes">
            Release  Notes
          </a>
        </div>
      </div>

      <a href="/datasets" class="navbar-item">
        Datasets
      </a>

      <a href="/blog" class="navbar-item">
        Blog
      </a>

      <a href="/insights" class="navbar-item">
        Insights
      </a>

      <a href="/contribute" class="navbar-item">
        Contribute!
      </a>

      <a href="https://github.com/rum-archive/rum-archive" class="navbar-item">
        Github
      </a>

      <a href="/about" class="navbar-item">
        About
      </a>
    </div>
  </div>
</nav>
</header>
  <main>
    
<article class="page-layout">
  <div class="container">
    <div class="columns">
      <div class="column is-10 is-offset-1">
        <div class="content m-5">
          <h1>RUM Insights PREVIEW TEST</h1>
          
          
<h2>Introduction</h2>

<p>
This page captures a collection of basic visualizations for the data contained in the RUM Archive. 
It's goal is to allow users to get a feel for the most important insights that can be gained from the data, without having to execute SQL queries themselves.
</p>

<p>
Note that we intentionally do not include interpretations of the data here, as this can often be quite nuanced. For that, look at our <a href="/blog">regular blog posts</a> that discuss RUM Insights in depth. 
</p>


<!-- TODO: merge these into a single file --> 
<script src="/js/highcharts/highstock.js" defer></script>
<script src="/js/highcharts/exporting.js" defer></script>
<script src="/js/highcharts/export-data.js" defer></script>
<script src="/js/highcharts/accessibility.js" defer></script>

<section class="doclist mt-3 pt-3">
    
  

  

    <div class="container">
      <div class="columns is-centered">
        <div class="column is-half control" style="text-align: center; vertical-align: middle;">
          <!-- <label class="label" for="marketshare_browser_version_select">Select browser:</label> -->
          <div class="select">
            <select id="userAgentSelect">
            </select>
          </div>
        </div>
      </div>
      <div id="ua_version" class="box">
      </div>
    </div>  

    <h2>Web Features Baseline Overview</h2>

    We count the percentage of page loads included in the RUM Archive on the first Tuesday of March 2024.

    <style>
      .table.is-hoverable tbody tr:not(.is-selected):hover, .clickable {
        cursor: pointer;
      }
    </style>

    <div class="container">
      <div id="baseline_desktop" class="box">
        <h3>Baseline support Desktop</h3>
        <div class="columns">
          <div class="column is-one-third">
            <table id="baseline_desktop_table" class="table is-hoverable">
              <thead>
                <tr>
                  <th>Baseline year</th>
                  <th>Supported by % of users of Tracked browsers <img class="clickable" onclick="showUsageDisclaimer('desktop')" src="/assets/question_mark.png" width="15px" /></th>
                </tr>
              </thead>
              <tbody>
                
              </tbody>
            </table>
          </div>
          <div id="baseline_desktop_details" class="column is-two-thirds">
            <h4>Details</h4>
            <div>Click on a row in the table to get more information per Baseline year</div>
          </div>
        </div>

      </div>

      <div id="baseline_mobile" class="box">
        <h3>Baseline support Mobile</h3>
        <div class="columns">
          <div class="column is-one-third">
            <table id="baseline_mobile_table" class="table is-hoverable">
              <thead>
                <tr>
                  <th>Baseline year</th>
                  <th>Supported by % of users of Tracked browsers <img class="clickable" onclick="showUsageDisclaimer('mobile')" src="/assets/question_mark.png" width="15px" /></th>
                </tr>
              </thead>
              <tbody>
                
              </tbody>
            </table>
          </div>
          <div id="baseline_mobile_details" class="column is-two-thirds">
            <h4>Details</h4>
            <div>Click on a row in the table to get more information per Baseline year</div>
          </div>
        </div>
      </div>
    </div>

</section>

<script type="module">

    import { Constants } from "/js/charts/constants.js";
    import * as TimeSeries from "/js/charts/timeseries.js"; 
    import * as Donuts from "/js/charts/donuts.js";
    import * as Area from "/js/charts/area.js";

    // 3 colors with good contrast, since we often have piecharts with exactly 2 or 3 entries
    const piecolors = [ TimeSeries.Colors.RUMARCHIVE_MAIN[0], TimeSeries.Colors.RUMARCHIVE_MAIN[1], TimeSeries.Colors.RUMARCHIVE_SECONDARY[5] ];

    const FORCE_EXTERNAL_DATA = false;
    let DATA_BASE_URL = "https://raw.githubusercontent.com/rum-archive/rum-insights-data/main/data-output/";

    if ( window.location.href.includes("localhost") && !FORCE_EXTERNAL_DATA ) {
      // allow for easy local testing
      // launch a basic python http server in the rum-insights-data dir with `python3 -m http.server 9000`
      DATA_BASE_URL = "http://localhost:9000/data-output/";
    }

    
    // returns e.g., "2023_12_01"
    function findLastDate(dataPoints) {
      // want to find the most recent datapoint in the file
      // for now, we don't actually parse the dates, but just assume the final entry in the list of dataPoints is part of the most recent batch
      if ( dataPoints && dataPoints.length > 0 && dataPoints[ dataPoints.length - 1].date ) {
        return dataPoints[ dataPoints.length - 1].date;
      }
      else {
        console.error("findLastDate: no 'date' property found on dataPoints, defaulting to 2023_12_01!", dataPoints);
        return "2024_03_05";
      }
    }

    


    let GLOBAL_selectedUserAgent = "";

    async function loadUserAgentSelectOptions() {

      let response = await fetch(DATA_BASE_URL + "useragentversion_useragentfamily_devicetype.json");
      let rumarchiveData = await response.json();
    
      // need to extract the unique useragentfamily_devicetype values
      let useragents = new Set();
      for( let row of rumarchiveData ) {
        useragents.add( row.client + "_" + row.family );
      }

      useragents = Array.from( useragents ).sort();

      const selectBox = document.getElementById("userAgentSelect");
      for ( let useragent of useragents ) {
        const option = document.createElement("option");
        const split = useragent.split("_");
        option.text = split[0] + " : " + split[1];
        option.value = useragent;
        selectBox.add(option);
      }

      selectBox.addEventListener("change", (event) => {
        GLOBAL_selectedUserAgent = event.target.value;
        TimeSeries.fromDataWithDefaults( "useragentversion_useragentfamily_devicetype", "ua_version", "version", GLOBAL_selectedUserAgent.split("_")[1] + " Versions", getUserAgentTimeSeries );
      });

      // load the default (first entry in the list)
      GLOBAL_selectedUserAgent =  rumarchiveData[0].client + "_" + rumarchiveData[0].family;
      TimeSeries.fromDataWithDefaults( "useragentversion_useragentfamily_devicetype", "ua_version", "version", rumarchiveData[0].family + " Versions", getUserAgentTimeSeries );

    }

    loadUserAgentSelectOptions();

    function getUserAgentTimeSeries(rumarchiveData, metricFieldName) {
      const [deviceType, useragentFamily] = GLOBAL_selectedUserAgent.split("_");
      rumarchiveData = rumarchiveData.filter( datapoint => (parseFloat(datapoint.percent) > 1) );
      rumarchiveData = rumarchiveData.filter( datapoint => datapoint.family === useragentFamily && datapoint.client === deviceType );

      console.log("Showing user agent ", GLOBAL_selectedUserAgent, rumarchiveData);

      let output = [];

      // need to give the graphing setup a list of timeseries, each with their own data and color
      // we want to generate these automatically from the data
      // 1. extract individual metricFieldValues (e.g., extract all individual device types)
      let metricValues = new Set();
      for ( let row of rumarchiveData )
        metricValues.add( row[metricFieldName] );

      for ( const [idx, metricValue] of [...metricValues].entries() ) {
        let timeSerie = {
          name: metricValue,
          data: rumarchiveData.filter( o => o[metricFieldName] === metricValue ),
          fields: ["percent"],
          color: TimeSeries.Colors.LIST[idx]
        };

        output.push( timeSerie );
      }

      return output;
    }


    async function populateBaselineInfo() {

      let ua_data_raw = await fetch(DATA_BASE_URL + "recent_useragentversion_useragentfamily_devicetype.json");
      let ua_data     = await ua_data_raw.json();

      let web_features_raw = await fetch(DATA_BASE_URL + "web-features.json"); 
      let web_features     = await web_features_raw.json();

      console.log( ua_data, web_features );

      // we want to create a baseline list for desktop vs mobile (which is what web-features gives us)
      // web-features is limited to:
      // Desktop: chrome, edge, firefox, safari
      // Mobile: chrome_android, firefox_android, safari_ios
    
      // so we filter out the accompanying ones from the RUM-archive for now
      // and map from RUMArchive names to web-features names to properly match
      // there are some gotchas in here to get the actual versions right (e.g., for Samsung Internet and Chrome Mobile), see later
      let desktopUAMappings = {
        "Chrome": "chrome",
        "Edge": "edge",
        "Firefox": "firefox",
        "Safari": "safari",

        "Samsung Internet": "chrome", // there is apparently a caveat with Linux, where Samsung Internet uses borked version numbers somehow?? Deal with that manually
        "Opera": "chrome",

        // "Chrome Mobile WebView": "chrome", // has some tiny presence on Desktop, probably bots etc. // best to not track though
      };

      let mobileUAMappings = {
        "Chrome": "chrome_android", // on Android OS, it's categorized as "Chrome" instead of "Chrome Mobile" by RUM Archive
        "Chrome Mobile": "chrome_android",
        "Chrome Mobile WebView": "chrome_android",
        "Firefox Mobile": "firefox_android",

        "Mobile Safari": "safari_ios",
        "Mobile Safari UI/WKWebView": "safari_ios",
        "Chrome Mobile iOS": "safari_ios", // all browsers on iOS are actually webkit under the hood
        "Firefox iOS": "safari_ios", // all browsers on iOS are actually webkit under the hood

        // "Edge Mobile": "mixed_chrome_safari", // this is a weird one... shows up both on Android and iOS, and needs split handling, so separate category is needed

        "Samsung Internet": "chrome_android",
        "Opera": "chrome_android",
        "Opera Mobile": "chrome_android",
      };

      let thingsThatAreActuallyWebkit = ["Chrome Mobile iOS", "Firefox iOS"];

      // create easy to use lookup arrays
      let desktopUAs  = Object.keys(desktopUAMappings);
      let mobileUAs   = Object.keys(mobileUAMappings);


      // want to keep details on which User Agents are tracked and which usage % they represent to show in the UI later
      let unknownUAsWithCounts = {};
      let knownUAsWithCounts = {};

      // to calculate percentages, need to know total beacon counts per platform for a given day
      // we want two different running counts, 1 for the Tracked browsers in desktopUAs and mobileUAs, and one for ALL browsers (including Untracked)
      let totalDesktopCount_subset = 0;
      let totalMobileCount_subset = 0;
      let totalDesktopCount_all = 0;
      let totalMobileCount_all = 0;

      for( let datapoint of ua_data ){

        let uaName = datapoint.family;
        let clientType = datapoint.client === "desktop" ? datapoint.client : "mobile"; // for mobile, we have both mobile and tablet in the RUMArchive, which need to be treated the same

        let uaKey = clientType + "_" + uaName;
        let dictionaryToUse = null;

        if ( datapoint.client === "desktop" ){
          
          // MANUAL OVERRIDE
          // there is apparently a caveat with Linux, where Samsung Internet uses borked version numbers somehow?? Deal with that manually
          if ( datapoint.family === "Samsung Internet" && datapoint.os === "Linux" ){
            // normally, SI is tracked, but here we treat it as untracked
            dictionaryToUse = unknownUAsWithCounts;
            totalDesktopCount_all += datapoint.count; 
            continue;
          }

          if ( desktopUAs.includes(datapoint.family)  ) {
            totalDesktopCount_subset += datapoint.count;

            dictionaryToUse = knownUAsWithCounts;
          }
          else {
            dictionaryToUse = unknownUAsWithCounts;
          }
          
          totalDesktopCount_all += datapoint.count; 
        }
        // for the purpose of Baseline, mobile and tablet are treated the same, 
        // since they use the same browsers (e.g., Chrome iOS is the same on iPhone as iPad)
        else if ( datapoint.client === "mobile" || datapoint.client === "tablet" ){
          if ( mobileUAs.includes(datapoint.family) ) {
            totalMobileCount_subset += datapoint.count;
            dictionaryToUse = knownUAsWithCounts;
          }
          else {
            dictionaryToUse = unknownUAsWithCounts;
          }
          
          totalMobileCount_all += datapoint.count; 
        }

        let uaTracker = dictionaryToUse[ uaKey ];
        if ( !uaTracker ) {
          uaTracker = { key: uaKey, ua: uaName, clientType: clientType, count: 0, osinfo: new Set() };
          dictionaryToUse[ uaKey ] = uaTracker;
        }
        uaTracker.count += datapoint.count;
        uaTracker.osinfo.add( datapoint.version + "@" + datapoint.os + "_" + datapoint.osversion );
      }

      console.log("Beacon Counts: (subset, all, diff)", totalDesktopCount_subset, totalDesktopCount_all, (totalDesktopCount_all - totalDesktopCount_subset), totalMobileCount_subset, totalMobileCount_all, (totalMobileCount_all - totalMobileCount_subset), ((totalMobileCount_all - totalMobileCount_subset)/totalMobileCount_all * 100).toFixed(2)  );

      // calculate usage percentages for both known and unknown UAs
      for( let uaEntry of Object.entries(knownUAsWithCounts) ) {
        let ua = uaEntry[1];

        if ( ua.ua.indexOf("desktop") >= 0 ) {
          ua.percentage_raw = (ua.count / totalDesktopCount_all) * 100;
          ua.percentage = ua.percentage_raw.toFixed(4) + "%";
        }
        else {
          ua.percentage_raw = (ua.count / totalMobileCount_all) * 100;
          ua.percentage = ua.percentage_raw.toFixed(4) + "%";
        }
      }
      for( let uaEntry of Object.entries(unknownUAsWithCounts) ) {
        let ua = uaEntry[1];

        if ( ua.ua.indexOf("desktop") >= 0 ) {
          ua.percentage_raw = (ua.count / totalDesktopCount_all) * 100;
          ua.percentage = ua.percentage_raw.toFixed(4) + "%";
        }
        else {
          ua.percentage_raw = (ua.count / totalMobileCount_all) * 100;
          ua.percentage = ua.percentage_raw.toFixed(4) + "%";
        }
      }

      knownUAsWithCounts = Object.values(knownUAsWithCounts).sort( (a,b) => b.percentage_raw - a.percentage_raw ).map( (a) => { a.osinfo = Array.from(a.osinfo); return a; } );
      unknownUAsWithCounts = Object.values(unknownUAsWithCounts).sort( (a,b) => b.percentage_raw - a.percentage_raw ).map( (a) => { a.osinfo = Array.from(a.osinfo); return a; } );

      console.log("Known UAs with counts:", knownUAsWithCounts);
      console.log("Unknown UAs with counts:", unknownUAsWithCounts);

      // use a global to make this easily accessible from showUsageDisclaimer
      // TODO: refactor global use ;) 
      window.uas = {};
      window.uas.known = knownUAsWithCounts;
      window.uas.unknown = unknownUAsWithCounts;

      // 1. per year, we need a list of features that were added to the baseline in that year with links (that's easy though)
      // 2. per year, we need a total COUNT of how many beacons belong to browsers whose version were >= versions that started to support that feature

      // 1.
      let baselineResults = [
        { clients: ["desktop"], uas: desktopUAs, uamappings: desktopUAMappings, totalCount: totalDesktopCount_subset, yearCounts: [] },
        { clients: ["mobile","tablet"], uas: mobileUAs, uamappings: mobileUAMappings, totalCount: totalMobileCount_subset, yearCounts: [] },
      ];

      let baselineFeaturesPerYear = {};
      for( let year = 2015; year <= 2024; year++ ) {
        let yearFeatures = [];
        // baseline dates are for the baseline_low_date (means low availability, but year is correct)
        for ( let web_feature of Object.values(web_features) ) {
          if ( web_feature.status && web_feature.status.baseline_low_date ) {
            let featureYear = web_feature.status.baseline_low_date.split("-")[0]; // format: 2023-05-09
            if ( featureYear === ("" + year) ){
              yearFeatures.push( web_feature );
            }
          }
          else if( web_feature.status && web_feature.status.baseline !== false ) {
            console.warn("SANITY CHECK: web feature doesn't have baseline_low_date yet!", web_feature);
          }
          else if ( !web_feature.status ) {
            // console.error("SANITY CHECK: web feature doesn't have status yet!", web_feature);
            // APPARENTLY there are a great many features without a status yet... just skip them for now 
          }
        }

        baselineFeaturesPerYear["" + year] = yearFeatures;
      }

      console.log( "Baseline features per year:", baselineFeaturesPerYear );

      // 2.
      for( let baselineEntry of baselineResults ) {
        const clients = baselineEntry.clients;
        const uas = baselineEntry.uas;
        const uamappings = baselineEntry.uamappings;
        const resultsPerYear = baselineEntry.yearCounts;

        for( let year = 2015; year <= 2024; year++ ){

          if ( !resultsPerYear[""+year] ) {
            resultsPerYear[""+year] = 0;
          }

          const featuresForCurrentYear = baselineFeaturesPerYear["" + year];

          // for now, we just need a running total count of beacons that we saw that are >= a given version, don't really need to keep detailed results
          // so we just loop over each version for each browser for each client type, and for each check if it's >= the year's expected versions for each webFeature

          for( let datapoint of ua_data ){
            if ( clients.includes(datapoint.client) && uas.includes(datapoint.family) ) {
              let version = datapoint.version;

              // for a given browser version entry, we need to see for ALL baseline features in that year if it's supported
              // this because e.g., a browser version could have gone live in July 202x but the baseline feature was only completed in the baseline in November 202x
              // We could theoretically also get this from the full baseline_low_date, but then we'd also need to know the release dates of all browser versions, which we don't :)
              // so: just check if we pass the version check for all of the webFeatures and only then add it to the resultsPerYear

              let passesAll = true; // assume yes

              for( let webFeature of featuresForCurrentYear ) {
                
                if( !webFeature.status ) {
                  console.error("SANITY CHECK: NO STATUS KNOWN, WHY NOT?!?", webFeature);
                }

                let webFeatureUAVersion = webFeature.status.support[ uamappings[datapoint.family] ];
                if ( webFeatureUAVersion ) {
                    let rumArchiveVersionRaw = datapoint.version;

                    // some browsers have their own version numbers, but are actually something else under the hood
                    // this is mainly iOS browsers, which map to their WebKit versions defined by the OS version rather than the browser version
                    // i.e., Chrome Mobile v122 on iOS 17.3 should ACTUALLY be counted as Safari 17.3 
                    // so we use the OSVersion for those type of browser instead
                    if( (datapoint.client === "mobile" || datapoint.client === "tablet") && thingsThatAreActuallyWebkit.includes(datapoint.family) ){
                      rumArchiveVersionRaw = datapoint.osversion;
                      // console.error("DEBUG: MAPPING WEBKIT MANUALLY", datapoint.family, datapoint.version, datapoint.osversion );
                    }

                    // Safari has subversions as part of the version string (i.e., 16.7)
                    // all other browsers only have integer versions
                    // just using a parse to float should work on both types (integers will just get .0)
                    let baselineVersionFloat = parseFloat(webFeatureUAVersion, 10);
                    let rumArchiveVersionFloat = parseFloat(datapoint.version, 10);

                    if ( rumArchiveVersionFloat < baselineVersionFloat ) {  
                      console.warn("Feature was too new!", year, datapoint.family, datapoint.os, uamappings[datapoint.family], rumArchiveVersionFloat, "<", baselineVersionFloat, webFeature.name, (parseInt(datapoint.count) / baselineEntry.totalCount ) * 100 );
                      passesAll = false;
                      break; // we already know we failed, so we can do an early exit 
                    }
                }
                else {
                  console.error("SANITY CHECK: current ua not known in web-features...", datapoint.family, uamappings[datapoint.family], webFeature.status.support );
                }
              }

              if ( passesAll ) {
                resultsPerYear["" + year] += parseInt(datapoint.count); 
              }
            }
          }
        }
      }

      for( let baselineResult of baselineResults ) {
        console.log("For ", baselineResult.client );

        let outputTable = document.getElementById("baseline_"+ baselineResult.clients[0] +"_table").getElementsByTagName('tbody')[0];

        for ( let year of Object.keys(baselineResult.yearCounts) ) {
          let counts = baselineResult.yearCounts[year];
          let percentage_subset = ((counts/baselineResult.totalCount) * 100).toFixed(2);

          let percentage_all = 0;
          let percentage_raw = 0;
          if ( baselineResult.clients[0] === "mobile" ) {
            percentage_raw = ((counts/totalMobileCount_all) * 100);
            percentage_all = ((counts/totalMobileCount_all) * 100).toFixed(2);
            console.log(baselineResult.clients[0] + " - ALL ", year, counts, "out of", totalMobileCount_all, "=", percentage_all );
            // console.error("MOBILE CHOSEN!");
          }
          else {
            percentage_raw = ((counts/totalDesktopCount_all) * 100);
            percentage_all = ((counts/totalDesktopCount_all) * 100).toFixed(2);
            console.log(baselineResult.clients[0] + " - ALL ", year, counts, "out of", totalDesktopCount_all, "=", percentage_all );
          }

          console.log("Subset ", year, counts, "out of", baselineResult.totalCount, "=", percentage_subset );

          let yearRow = outputTable.insertRow();
          yearRow.setAttribute("baseline-year", year + "_" + percentage_subset);
          // let yearCell = yearRow.insertCell(0);

          let yearCell = document.createElement("th");
          yearRow.appendChild(yearCell);
          let resultCell = yearRow.insertCell(1);

          //let diff = 1.32 + (100 - ((counts/baselineResult.totalCount) * 100));


          yearCell.innerHTML = "" + year;
          // resultCell.innerHTML = "" + percentage_all + "% - " + percentage_subset + "% (" + ( (((counts/baselineResult.totalCount) * 100) / percentage_raw).toFixed(2) + ")" );
          resultCell.style = "text-align: center;";
          resultCell.innerHTML = "" + percentage_subset + "%";
        }

        outputTable.addEventListener("click", (evt) => {
          if ( !evt.target )
            return;

          // the click is usually the year <th> or the percentage <td>
          // we need to get parent tr if that's the case
          let row = evt.target;
          let yearPercent = evt.target.getAttribute("baseline-year");

          if ( !yearPercent && evt.target.parentNode ){
            yearPercent = evt.target.parentNode.getAttribute("baseline-year");
            row = evt.target.parentNode;
          }

          if ( !yearPercent ) // can't find the baseline-year... nothing left to do
            return;
          
          // make sure old element is deselected
          const currentlySelected = outputTable.getElementsByClassName("is-selected");
          for ( let cs of currentlySelected ) {
            cs.classList.remove("is-selected");
          }

          // select current row
          row.classList.add("is-selected");
          
          const year = yearPercent.split("_")[0];
          const percentage = yearPercent.split("_")[1];

          let detailsContainer = document.getElementById("baseline_"+ baselineResult.clients[0] +"_details");
          detailsContainer.getElementsByTagName("h4")[0].textContent = "Details for Baseline " + year;

          let detailsContent = "If you target the following Web features for "+year+"'s Baseline, <b>" + percentage + "%</b> of "+ baselineResult.clients[0] +" users in the RUM Archive for the main browsers would benefit:<br /><br />";

          // we want to group compat features by type (CSS, JS, HTML, API, Other)
          let groups = {
            "api": new Set(),
            "css": new Set(),
            "javascript": new Set(),
            "html": new Set(),
            "http": new Set(),
            "svg": new Set(),
            "other": new Set(),
          };

          for ( let feature of baselineFeaturesPerYear[year] ) {
            console.log("feature", feature);

            let compat_features = feature.compat_features;
            if( compat_features ){

              // compat_features can have multiple subfeatures listed, each belonging to a specific group
              // e.g., you can have 
              // [ "api.feature.1", "api.feature.2", "html.feature.x", "html.feature.y" ]
              // we only want to show the feature ONCE under a group (so for the example, we don't want to show both in API AND HTML, but only HTML)
              // so, we can't just look at the first one in the list, because APIs are a bit special
              // (most features will have an API subfeature... if there is any other grouping possible (e.g., HTML in the example) then that should be preferred)
              // so, we special-case api.

              // check if all compat_features are in the same feature group
              let guessedGroup = null;
              let hasAPIgroup = false;
              for ( let compat_feature of compat_features ){ 
                let currentGroup = compat_feature.split(".")[0]; 

                if ( currentGroup === "api" )
                  hasAPIgroup = true;
                else if( guessedGroup === null )
                  guessedGroup = currentGroup;
                else if ( guessedGroup !== currentGroup ) {
                  console.error("INCONSISTENT compat_features! ", currentGroup, "!=", guessedGroup, compat_features, feature);
                }
              }

              if ( guessedGroup === null ) {
                // no group found. Could mean 1 of 2 things
                // 1. it is really an API feature: put into that group
                // 2. it simply doesn't have a known group: put it as "other"
                if ( hasAPIgroup ) {
                  guessedGroup = "api";
                }
                else {
                  guessedGroup = "other";
                }
              }

              groups[guessedGroup].add( feature );

              /*
              for ( let compat_feature of compat_features ){ 
                let prefix = compat_feature.split(".")[0]; // e.g., of the form 'html.elements.script.nomodule', 'javascript.statements.export'
                
                if( !groups[prefix] ) {
                  console.error("SANITY CHECK: feature group not yet known! skipping...", prefix, feature);
                  continue;
                }

                groups[prefix].add( feature );
              }
              */
            }
            else {
              // e.g., AVIF support doesn't have compat_features
              groups["other"].add( feature );
            }
          }

          console.log( groups );

          for ( let group of Object.entries(groups) ) {
            if( group[1].size === 0 )
              continue;

            detailsContent += "<h5>" + group[0] + "</h5><ul>";

            for ( let feature of group[1] ) {

              // some feature's name is a valid HTML element tag... LOOKING AT YOU <detail>... urgh
              let name = feature.name.replaceAll('<', '&lt;').replaceAll('>', '&gt;');

              detailsContent += "<li><a href=\"https://caniuse.com/"+ feature.caniuse +"\" target=\"_blank\">" + name + "</a></li>";
            }

            detailsContent += "</ul>"
          }

          let textContainer = detailsContainer.getElementsByTagName("div")[0];
          textContainer.innerHTML = detailsContent;
        });
      }

      console.log( baselineResults );
    }

    populateBaselineInfo();


</script>

<script>

    function showUsageDisclaimer(clientType) {
      // make sure any currently selected rows in the output table is deselected

      let featuresTable = document.getElementById("baseline_"+ clientType +"_table").getElementsByTagName('tbody')[0];
      
      // make sure old element is deselected
      const currentlySelected = featuresTable.getElementsByClassName("is-selected");
      for ( let cs of currentlySelected ) {
        cs.classList.remove("is-selected");
      }

      let detailsContainer = document.getElementById("baseline_"+ clientType +"_details");
      detailsContainer.getElementsByTagName("h4")[0].textContent = "Disclaimer about usage tracking";

      let percentage_noise = 0.0;
      let unknownText = "";
      let knownText = "";

      for ( let ua of window.uas.unknown ) {
        if ( ua.clientType !== clientType )
          continue;

        percentage_noise += ua.percentage_raw;

        unknownText += `<li> ${ua.ua} : ${ ua.percentage_raw.toFixed(4) }% (${ ua.count} beacons) </li>`;
      }

      for ( let ua of window.uas.known ) {
        if ( ua.clientType !== clientType )
          continue;

        knownText += `<li> ${ua.ua} : ${ ua.percentage_raw.toFixed(4) }% (${ ua.count} beacons) </li>`;
      }

      let detailsText = 
          `<p>
              We do not track feature support for every browser/User Agent. Some browsers are too old, or the information is not public, 
              or they are bots/attack traffic, which is present in the RUM data but impossible to verify. 
            </p>

            <p>
              The main results displayed in this table intentionally only take into account the tracked/known browsers. 
              For example, if the table shows 100% baseline support, this means 100% of the Tracked browsers support the baseline, not taking into account unknown User Agents.
            </p>
            <p>
              For the current date, the unknown User Agents account for <b>${ percentage_noise.toFixed(2) }%</b> of total ${clientType} beacons seen.
              Below you can find a detailed list of the usage share of each User Agent (both Tracked and Untracked).
            </p>
           `;

        for ( let ua of window.uas.unknown ) {
          if ( ua.clientType === clientType )
            percentage_noise += ua.percentage_raw;
        }

        detailsText += `
          <details>
            <summary>Untracked User Agents for ${clientType}</summary>
            <ul>${unknownText}</ul>
            <p>Note: some of these User Agents might seem at first glance like they could be tracked (e.g., named after one of the main browsers), 
              but these often show up in impossible combinations (e.g., Chrome Mobile on Windows Desktop) and are likely bots that we intentionally exclude.
          </details>
          <br />
          <details>
            <summary>Tracked User Agents for ${clientType}</summary>
            <ul>${knownText}</ul>
          </details>
        `;
     

      let textContainer = detailsContainer.getElementsByTagName("div")[0];
      textContainer.innerHTML = detailsText;
    }

</script>

        </div>
      </div>
    </div>
  </div>
</article>

  </main>
  <footer class="footer">
    <div class="content has-text-centered">
      <p>
        Sponsored by <a href="https://akamai.com">Akamai</a>.
        The website content is licensed
        <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>.
      </p>
      <p>
        <a href="https://twitter.com/RUMArchive">twitter</a> -
        <a rel="me" href="https://webperf.social/@rumarchive">mastodon</a>
      </p>
    </div>
  </footer>
</body>
</html>
