---
title: RUM Insights
description: RUM Insights home
layout: layouts/page.njk
---

<h2>Introduction</h2>

<p>
This page captures a collection of basic visualizations for the data contained in the RUM Archive. 
It's goal is to allow users to get a feel for the most important insights that can be gained from the data, without having to execute SQL queries themselves.
</p>

<p>
Note that we intentionally do not include interpretations of the data here, as this can often be quite nuanced. For that, look at our <a href="/blog">regular blog posts</a> that discuss RUM Insights in depth. 
</p>


<!-- TODO: merge these into a single file --> 
<script src="/js/highcharts/highstock.js" defer></script>
<script src="/js/highcharts/exporting.js" defer></script>
<script src="/js/highcharts/export-data.js" defer></script>
<script src="/js/highcharts/accessibility.js" defer></script>

<section class="doclist mt-3 pt-3">

  <h2 id="marketshares">Market Shares</h2>

    <p>
      It is important to know which devices, operating systems and browsers your visitors are using to access your sites, as hardware power and feature support can differ widely. 
      This helps you better optimize your sites for your target audience.
    </p>

  <h3 id="device-marketshare">Device Type</h3>

    <p>
      The following graphs show the usage of different Device Types (RUM Archive currently only tracks 3 device types).
    </p> 
    
  <div class="container">
    <div id="marketshare_devicetypes" class="box">
    </div>
  </div>

  <h3 id="os-marketshare">Operating System</h3>

  <p>
    The following graphs show the usage of different Operating Systems for Desktop and Mobile devices (OSes with &lt; 1% usage share have been filtered out).
  </p> 
  <div class="container">
    <div class="columns box">
      <div class="column" id="marketshare_os_desktop">
      </div>
      <div class="column" id="marketshare_os_mobile">
      </div>
    </div>
  </div>

  <h3 id="ua-marketshare">Browser</h3>

    <p>
      The following charts show the usage of different Browsers / User Agents for Desktop and Mobile devices (entries with &lt; 1% usage share have been filtered out). 
      The data shown is from February 6th 2024. 
    </p> 

    <div class="columns box">
      <div class="column" id="marketshare_browser_desktop">
      </div>
      <div class="column" id="marketshare_browser_mobile">
      </div>
    </div>
    
  <h3 id="ua-version-marketshare">Browser Versions</h3>

    <p>
      The following chart shows the usage of different versions of popular Browsers / User Agents for Desktop and Mobile devices. Use the dropdown to select a browser and platform. Note that User Agent parsing is done using the <a href="https://github.com/ua-parser/uap-core">ua-parser</a> library.
    </p> 
    <p>
      The data points shown are from the first and third Tuesdays of every month. 
    </p> 

    <div class="container">
      <div class="columns is-centered">
        <div class="column is-half control" style="text-align: center; vertical-align: middle;">
          <!-- <label class="label" for="marketshare_browser_version_select">Select browser:</label> -->
          <div class="select">
            <select id="marketshare_browser_version_select">
            </select>
          </div>
        </div>
      </div>
      <div id="marketshare_browser_version" class="box">
      </div>
    </div>  

  <h2 id="navigation-aspects">Navigational Aspects</h2>

    <p>
      While for performance measurements and optimization we often focus on a full page load in its own tab (often as first page in a session) not all navigations are of course like that. 
      In this section, we explore other types of navigations and how often they occur within the RUM Archive dataset.
    </p>

    <p>
      The data shown is from February 6th 2024.
    </p>

    <h3 id="navigationtype-aspect">Navigation Types</h3>
    
      <p>
        The following graphs show the usage of different <a href="https://techdocs.akamai.com/mpulse-boomerang/docs/whats-in-an-mpulse-beacon#top-level-fields">Navigation Types</a>. 
      </p> 

      <ul>
        <li>Navigation is a typical navigation by for example clicking on a link.</li>
        <li>Reload is when the user manually reloads the page.</li> 
        <li>Back-forward is when the user uses the back and forward buttons to navigate in their history.</li> 
      </ul>
      
      <div class="columns box">
        <div class="column" id="navigationtype_desktop">
        </div>
        <div class="column" id="navigationtype_mobile">
        </div>
      </div>

    <h3 id="visibilitystate-aspect">Visibility State</h3>

      <p>
        The following graphs show the usage of different <a href="https://techdocs.akamai.com/mpulse-boomerang/docs/whats-in-an-mpulse-beacon#visibility-state">Visibility States</a>. 
      </p> 

      <ul>
        <li>Visible typically means the user watched the page load happen.</li>
        <li>Hidden is for example when the user clicks to open the page in a new (yet hidden) tab.</li> 
        <li>Partial is when the page load starts hidden, but the user switches to the still rendering page before it's done (for example, they rapidly switch to a background tab).</li> 
      </ul>
      
    <div class="columns box">
      <div class="column" id="visibilitystate_desktop">
      </div>
      <div class="column" id="visibilitystate_mobile">
      </div>
    </div>

    <h3 id="landingpage-aspect">Landing Page</h3>

      <p>
        The following graphs show how many navigations were to a site's <a href="https://techdocs.akamai.com/mpulse-boomerang/docs/whats-in-an-mpulse-beacon#debugging-info-and-timestamps">Landing Page</a>. 
      </p> 
      <p>
        A landing page is the first page a user visits during a new "session" on a given website. This does not always have to be the "homepage", as it can be any page of a site, as long as it is the first a user visits.
      </p>
      <p> 
        A session is typically (though not always) defined as a series of navigations separate by no more than 30 minutes (after 30 minutes, the session automatically ends and the next navigation starts a new session).
      </p>
      
    <div class="columns box">
      <div class="column" id="landingpage_desktop">
      </div>
      <div class="column" id="landingpage_mobile">
      </div>
    </div>


    <h3 id="spa-aspect">Multi vs Single Page Apps</h3>

        <p>
          The following graphs show the amount of (typical) "multi-page app" (MPA) loads versus "single-page app" (SPA) loads. 
          SPA navigations can be broken down into both Hard Navigations (the first navigation to the page) and Soft Navigations (in-page route changes). 
        </p> 
        
      <div class="columns box">
        <div class="column" id="spa_desktop">
        </div>
        <div class="column" id="spa_mobile">
        </div>
      </div>


  <h2 id="about">About RUM Insights</h2>
    <p>
      RUM Insights is intended to grow into a wide collection of default visualizations of the underlying RUM Archive data, updated once a month. 
      The current version is limited to just a few graphs for some key data. 
      If you have ideas about additional graphs or new features, let us know on <a href="https://github.com/rum-archive/rum-archive">GitHub</a>.
    </p>
    <p>
      The BigQuery queries used to generate data for these graphs and their outputs can be found in the separate <a href="https://github.com/rum-archive/rum-insights-data/tree/main/queries">rum-insights-data GitHub repository</a>.
    </p>


</section>

<script type="module">

    // import HighCharts from "/js/charts/timeseries.js";

    import { Constants } from "/js/charts/constants.js";
    import * as TimeSeries from "/js/charts/timeseries.js"; 
    import * as Donuts from "/js/charts/donuts.js";
    import * as Area from "/js/charts/area.js";

    // 3 colors with good contrast, since we often have piecharts with exactly 2 or 3 entries
    const piecolors = [ TimeSeries.Colors.RUMARCHIVE_MAIN[0], TimeSeries.Colors.RUMARCHIVE_MAIN[1], TimeSeries.Colors.RUMARCHIVE_SECONDARY[5] ];
    
    // returns e.g., "2023_12_01"
    function findLastDate(dataPoints) {
      // want to find the most recent datapoint in the file
      // for now, we don't actually parse the dates, but just assume the final entry in the list of dataPoints is part of the most recent batch
      if ( dataPoints && dataPoints.length > 0 && dataPoints[ dataPoints.length - 1].date ) {
        return dataPoints[ dataPoints.length - 1].date;
      }
      else {
        console.error("findLastDate: no 'date' property found on dataPoints, defaulting to 2024_02_06!", dataPoints);
        return "2024_02_06";
      }
    }

    function getDeviceTypeTimeseries(rumarchiveData, metricFieldName) {
      rumarchiveData = rumarchiveData.filter( datapoint => (parseFloat(datapoint.percent) > 1) );

      let output = [];

      // need to give the graphing setup a list of timeseries, each with their own data and color
      // we want to generate these automatically from the data
      // 1. extract individual metricFieldValues (e.g., extract all individual device types)
      let metricValues = new Set();
      for ( let row of rumarchiveData )
        metricValues.add( row[metricFieldName] );

      for ( let metricValue of metricValues ) {
        let timeSerie = {
          name: metricValue,
          data: rumarchiveData.filter( o => o[metricFieldName] === metricValue ),
          fields: ["percent"],
          color: (metricValue === "Desktop") ? TimeSeries.Colors.DESKTOP : ( (metricValue === "Mobile") ? TimeSeries.Colors.MOBILE : TimeSeries.Colors.TABLET )
        };

        output.push( timeSerie );
      }

      return output;
    }

    TimeSeries.fromDataWithDefaults( "devicetype", "marketshare_devicetypes", "device", "Device Type", getDeviceTypeTimeseries );
    // renderDeviceTypeTimeseries();


    async function renderOSTimeseries(clientType, chartId, chartName) {
        try {
          const metricFieldName = "os";
          const queryName = "os_devicetype";

          let response = await fetch( Constants.getDataURL(queryName) );
          let rumarchiveData = await response.json();
        
          rumarchiveData = rumarchiveData.filter( datapoint => (datapoint.client === clientType) && (parseFloat(datapoint.percent) > 0.5) );

          const options = {};
          options.chartId = chartId;
          options.histogram = { enabled: false };
          options.metric = metricFieldName;
          options.queryURL = Constants.getQueryURL(queryName);

          // need to give the graphing setup a list of timeseries, each with their own data and color
          // we want to generate these automatically from the data
          // 1. extract individual metricFieldValues (e.g., extract all individual device types)
          let metricValues = new Set();
          for ( let row of rumarchiveData )
            metricValues.add( row[metricFieldName] );

          let osColors = TimeSeries.Colors.LIST;

          options.timeseries = [];
          for ( const [idx, metricValue] of [...metricValues].entries() ) {
            let timeSerie = {
              name: metricValue,
              data: rumarchiveData.filter( o => o[metricFieldName] === metricValue ),
              fields: ["percent"],
              color: osColors[idx]
            };

            options.timeseries.push( timeSerie );
          }

          options.type = "%";

          options.id = "os";
          options.name = chartName;

          options.yMax = 100;

          TimeSeries.fromData(rumarchiveData, metricFieldName, options, rumarchiveData[0].date, rumarchiveData[rumarchiveData.length - 1].date );
        }
        catch(e) {
          console.error(e);
          return;
        }
    }
    
    renderOSTimeseries("desktop", "marketshare_os_desktop", "Desktop Operating System");
    renderOSTimeseries("mobile", "marketshare_os_mobile", "Mobile Operating System");


    async function renderBrowserPiechart(clientType, chartId, chartName) {
      const options = {};

      const metricFieldName = "useragent";

      const queryName = "LCPCount_useragentfamily_" + clientType;

      let response = await fetch( Constants.getDataURL(queryName) );
      let rumarchiveData = await response.json();

      // this data is a bit different:
      // - always contains only data for a single devicetype (no need to filter on device)
      // - split into two datasets: one with each individual browser, one with them grouped
      /*{
        "individual": [
          {"device":"desktop","date":"2023_09_01","cwvpercent":"0.1","useragentpercent":"0.0","useragent":"Chromium"}
        ],
        "grouped", [
          {"device":"desktop","date":"2023_09_01","useragentgroup":"Others","cwvpercent":"0.4","useragentpercent":"1.2"}
        ]
      }*/

      // normally, we need the individual measurements and use the "useragentpercent" as the value
      rumarchiveData = rumarchiveData.individual;

      rumarchiveData = rumarchiveData.filter( datapoint => (parseFloat(datapoint.useragentpercent) > 0.5) );

      let datapoints = rumarchiveData;
      // want to assign colors based on contribution: largest part gets the primary color, 2nd largest secondary color, etc.
      datapoints = datapoints.sort((a, b) => { return parseFloat(b["useragentpercent"]) - parseFloat(a["useragentpercent"]) } ); // desc sort
      datapoints = datapoints.map( (val, idx) => { val.color = TimeSeries.Colors.LIST[idx]; return val; } );

      options.chartId = chartId;
      options.name = chartName;
      options.queryURL = Constants.getQueryURL(queryName);

      options.datapoints = datapoints;
      options.datapointFieldname = "useragentpercent";

      Donuts.fromData( metricFieldName, options );

    }

    renderBrowserPiechart("desktop", "marketshare_browser_desktop", "Desktop browsers");
    renderBrowserPiechart("mobile", "marketshare_browser_mobile", "Mobile browsers");


    // Start: browser version select
    // This one is a bit different, in that we need to manually select a slicing of the data and make it update-able
    // to keep track of which one is currently selected, we use a global variable just to make it easy to access
    // (instead of having to go to the <select> with DOM every time)

    // we first load the data to be able to populate the <select> and auto-select the first one
    // NOTE: we rely on the data to be cached in the browser to prevent fetching again in TimeSeries.fromDataWithDefaults when the user changes selection!
    let GLOBAL_selectedUserAgent = "";

    async function loadUserAgentSelectOptions() {

      let response = await fetch( Constants.getDataURL("useragentversion_useragentfamily_devicetype") );
      let rumarchiveData = await response.json();
    
      // The raw data includes bots/outliers, meaning unexpected browsers show up for some platforms
      // for example, we have some dozens of page loads for "Chrome Mobile iOS" on desktop, which doesn't make sense
      // I manually went through all the platform + family combinations to see which had proper marketshare
      // the ones below do not, so we filter them here
      // Note: even on Mobile, Opera Mini has a tiny marketshare, so we skip it alltogether
      // TODO: this should probably happen during the processing step of the data in rum-insights-data instead :) 
      let skipSet = [];
      skipSet["desktop"] = [
        "Firefox Mobile",
        "Opera Mini",
        "Chrome Mobile WebView",
        "Chrome Mobile",
        "Chrome Mobile iOS",
        "Facebook",
      ];
      skipSet["mobile"] = [
        "Chrome",
        "Opera Mini",
        "Edge",
        "Safari",
      ];

      // need to extract the unique useragentfamily_devicetype values we have available
      // since browser names (.family) are not unique across platforms, we include the platform (.client) in the option ID
      // e.g., will be mobile_chrome
      let useragents = new Set();
      for( let row of rumarchiveData ) {
        // for now, we're not interested in Tablet numbers specifically, so leave them out 
        if( row.client === "tablet")
          continue;
        
        // skip browser if it's in the skipset manually defined above
        if ( skipSet[row.client].indexOf(row.family) >= 0 )
          continue;

        useragents.add( row.client + "_" + row.family );
      }

      useragents = Array.from( useragents ).sort(); // mainly to sort on platform

      const selectBox = document.getElementById("marketshare_browser_version_select");
      for ( let useragentkey of useragents ) {
        const option = document.createElement("option");
        const split = useragentkey.split("_");
        option.text = split[0][0].toUpperCase() + split[0].slice(1) + " : " + split[1];
        option.value = useragentkey;
        selectBox.add(option);
      }

      selectBox.addEventListener("change", (event) => {
        GLOBAL_selectedUserAgent = event.target.value;
        TimeSeries.fromDataWithDefaults( "useragentversion_useragentfamily_devicetype", "marketshare_browser_version", "version", GLOBAL_selectedUserAgent.split("_")[1] + " Versions", getUserAgentTimeSeries );
      });

      // load the default (first entry in the list)
      GLOBAL_selectedUserAgent =  useragents[0];
      TimeSeries.fromDataWithDefaults( "useragentversion_useragentfamily_devicetype", "marketshare_browser_version", "version", useragents[0].split("_")[1] + " Versions", getUserAgentTimeSeries );

    }

    loadUserAgentSelectOptions();

    // the JSON file from the server contains info for ALL browsers: need to filter based on what was actually selected. 
    function getUserAgentTimeSeries(rumarchiveData, metricFieldName) {
      const [deviceType, useragentFamily] = GLOBAL_selectedUserAgent.split("_");
      rumarchiveData = rumarchiveData.filter( datapoint => (parseFloat(datapoint.percent) > 1) );
      rumarchiveData = rumarchiveData.filter( datapoint => datapoint.family === useragentFamily && datapoint.client === deviceType );

      console.log("Showing user agent ", GLOBAL_selectedUserAgent, rumarchiveData);

      let output = [];

      // need to give the graphing setup a list of timeseries, each with their own data and color
      // we want to generate these automatically from the data
      // 1. extract individual metricFieldValues (e.g., extract all individual device types)
      let metricValues = new Set();
      for ( let row of rumarchiveData )
        metricValues.add( row[metricFieldName] );

      for ( const [idx, metricValue] of [...metricValues].entries() ) {
        let timeSerie = {
          name: metricValue,
          data: rumarchiveData.filter( o => o[metricFieldName] === metricValue ),
          fields: ["percent"],
          color: TimeSeries.Colors.LIST[idx]
        };

        output.push( timeSerie );
      }

      return output;
    }



    {# async function renderBrowserGroupedPiechart(clientType, chartId, chartName) {
      const options = {};

      const metricFieldName = "useragentgroup";

      let response = await fetch(DATA_BASE_URL + "LCPCount_useragentfamily_" + clientType + ".json");
      let rumarchiveData = await response.json();

      // normally, we need the individual measurements and use the "useragentpercent" as the value
      rumarchiveData = rumarchiveData.grouped;

      rumarchiveData = rumarchiveData.filter( datapoint => (parseFloat(datapoint.useragentpercent) > 0.5) );

      let datapoints = rumarchiveData;
      // want to assign colors based on contribution: largest part gets the primary color, 2nd largest secondary color, etc.
      datapoints = datapoints.sort((a, b) => { return parseFloat(b["useragentpercent"]) - parseFloat(a["useragentpercent"]) } ); // desc sort
      datapoints = datapoints.map( (val, idx) => { val.color = TimeSeries.Colors.LIST[idx]; return val; } );

      console.log("DONUTS", datapoints);

      // manual override to keep colors semantically consistent
      if ( clientType === "mobile" ) {
        datapoints.filter( (p) => p.useragentgroup == "Webkit (Safari, no CWV)" )[0].color = TimeSeries.Colors.RUMARCHIVE_ORANGE_1;
        datapoints.filter( (p) => p.useragentgroup == "Webkit (Others, no CWV)" )[0].color = TimeSeries.Colors.RUMARCHIVE_ORANGE_2;
      }
      else {
        datapoints.filter( (p) => p.useragentgroup == "Safari" )[0].color   = TimeSeries.Colors.RUMARCHIVE_ORANGE_1;
        datapoints.filter( (p) => p.useragentgroup == "Firefox" )[0].color  = TimeSeries.Colors.RUMARCHIVE_SCARLET;
      }

      datapoints.filter( (p) => p.useragentgroup == "Chrome (CWV + CrUX)" )[0].color     = TimeSeries.Colors.RUMARCHIVE_BLUE_1;
      datapoints.filter( (p) => p.useragentgroup == "Chromium (CWV, no CrUX)" )[0].color = TimeSeries.Colors.RUMARCHIVE_BLUE_2;
      datapoints.filter( (p) => p.useragentgroup == "Others" )[0].color                  = TimeSeries.Colors.RUMARCHIVE_GREEN;

      options.chartId = chartId;
      options.name = chartName;

      options.datapoints = datapoints;
      options.datapointFieldname = "useragentpercent";

      Donuts.fromData( metricFieldName, options );
    }

    renderBrowserGroupedPiechart("desktop", "marketshare_browsergrouped_desktop", "Desktop browsers (grouped)");
    renderBrowserGroupedPiechart("mobile", "marketshare_browsergrouped_mobile", "Mobile browsers (grouped)"); #}


    // TODO: inject another graph that shows useragentpercent grouped (for perfnow) and maybe ungrouped cwvpercent as well (first that, then grouped for better understanding)

    {# async function renderBrowserCruxPiechart(clientType, chartId, chartName) {
      const options = {};

      const metricFieldName = "useragentgroup";

      let response = await fetch(DATA_BASE_URL + "LCPCount_useragentfamily_" + clientType + ".json");
      let rumarchiveData = await response.json();

      rumarchiveData = rumarchiveData.grouped;

      // rumarchiveData = rumarchiveData.filter( datapoint => (parseFloat(datapoint.cwvpercent) > 0.5) );

      let datapoints = rumarchiveData;
      // want to assign colors based on contribution: largest part gets the primary color, 2nd largest secondary color, etc.
      datapoints = datapoints.sort((a, b) => { return parseFloat(b["cwvpercent"]) - parseFloat(a["cwvpercent"]) } ); // desc sort
      datapoints = datapoints.map( (val, idx) => { val.color = TimeSeries.Colors.LIST[idx]; return val; } );

      options.chartId = chartId;
      options.name = chartName;

      options.datapoints = datapoints;
      options.datapointFieldname = "cwvpercent";

      Donuts.fromData( metricFieldName, options );
    }


    renderBrowserCruxPiechart("desktop", "marketshare_cwvbrowser_desktop", "Desktop browsers that support CWV");
    renderBrowserCruxPiechart("mobile", "marketshare_cwvbrowser_mobile", "Mobile browsers that support CWV"); #}
    

    async function renderNavigationTypePiechart(clientType, chartId, chartName) {
      const options = {};

      const metricFieldName = "navigationtype";

      const queryName = "navigationtype_devicetype";

      let response = await fetch( Constants.getDataURL(queryName) );
      let rumarchiveData = await response.json();

      const valueKey = "percent";

      // the dataset contains data for each month, but for the piechart here, we only want to latest
      const date = findLastDate(rumarchiveData);
      let datapoints = rumarchiveData.filter( point => point.date == date && point.client == clientType );

      // want to assign colors based on contribution: largest part gets the primary color, 2nd largest secondary color, etc.
      datapoints = datapoints.sort((a, b) => { return parseFloat(b[valueKey]) - parseFloat(a[valueKey]) } ); // desc sort
      datapoints = datapoints.map( (val, idx) => { val.color = piecolors[idx]; return val; } );

      options.chartId = chartId;
      options.name = chartName;
      options.datapoints = datapoints;
      options.datapointFieldname = valueKey;
      options.queryURL = Constants.getQueryURL(queryName);

      Donuts.fromData( metricFieldName, options );
    }

    renderNavigationTypePiechart("desktop", "navigationtype_desktop", "Navigation Types (Desktop)");
    renderNavigationTypePiechart("mobile", "navigationtype_mobile", "Navigation Types (Mobile)");

    async function renderVisibilityStatePiechart(clientType, chartId, chartName) {
      const options = {};

      const metricFieldName = "visibilitystate";
      const queryName = "visibilitystate_devicetype";

      let response = await fetch( Constants.getDataURL(queryName) );
      let rumarchiveData = await response.json();

      const valueKey = "percent";

      // the dataset contains data for each month, but for the piechart here, we only want to latest
      const date = findLastDate(rumarchiveData);
      let datapoints = rumarchiveData.filter( point => point.date == date && point.client == clientType );

      // want to assign colors based on contribution: largest part gets the primary color, 2nd largest secondary color, etc.
      datapoints = datapoints.sort((a, b) => { return parseFloat(b[valueKey]) - parseFloat(a[valueKey]) } ); // desc sort
      datapoints = datapoints.map( (val, idx) => { val.color = piecolors[idx]; return val; } );

      options.chartId = chartId;
      options.name = chartName;
      options.datapoints = datapoints;
      options.datapointFieldname = valueKey;
      options.queryURL = Constants.getQueryURL(queryName);

      Donuts.fromData( metricFieldName, options );
    }

    renderVisibilityStatePiechart("desktop", "visibilitystate_desktop", "Visibility States (Desktop)");
    renderVisibilityStatePiechart("mobile", "visibilitystate_mobile", "Visibility States (Mobile)");

    async function renderLandingPagePiechart(clientType, chartId, chartName) {
      const options = {};

      const metricFieldName = "landingpage";
      const queryName = "landingpage_devicetype";

      let response = await fetch( Constants.getDataURL(queryName) );
      let rumarchiveData = await response.json();

      const valueKey = "percent";

      // the dataset contains data for each month, but for the piechart here, we only want to latest
      const date = findLastDate(rumarchiveData);
      let datapoints = rumarchiveData.filter( point => point.date == date && point.client == clientType );

      // want to assign colors based on contribution: largest part gets the primary color, 2nd largest secondary color, etc.
      datapoints = datapoints.sort((a, b) => { return parseFloat(b[valueKey]) - parseFloat(a[valueKey]) } ); // desc sort
      datapoints = datapoints.map( (val, idx) => { val.color = piecolors[idx]; return val; } );

      options.chartId = chartId;
      options.name = chartName;
      options.datapoints = datapoints;
      options.datapointFieldname = valueKey;
      options.queryURL = Constants.getQueryURL(queryName);

      Donuts.fromData( metricFieldName, options );
    }

    renderLandingPagePiechart("desktop", "landingpage_desktop", "Landing Page (Desktop)");
    renderLandingPagePiechart("mobile", "landingpage_mobile", "Landing Page (Mobile)");


    async function renderBeaconTypePiechart(clientType, chartId, chartName) {
      const options = {};

      const metricFieldName = "beacontype";
      const queryName = "beacontype_devicetype";

      let response = await fetch( Constants.getDataURL(queryName) );
      let rumarchiveData = await response.json();

      const valueKey = "percent";

      // the dataset contains data for each month, but for the piechart here, we only want to latest
      const date = findLastDate(rumarchiveData);
      let datapoints = rumarchiveData.filter( point => point.date == date && point.client == clientType );

      // TODO: allow bfcache if the amount picks up (right now, only 0.1% max, looks weird)
      datapoints = datapoints.filter( point => point.beacontype !== "bfcache" );

      // want to assign the same colors to the same thing, even if the distributions are different, so have to do that manually
      datapoints = datapoints.sort((a, b) => { return parseFloat(b[valueKey]) - parseFloat(a[valueKey]) } ); // desc sort
      // datapoints = datapoints.map( (val, idx) => { val.color = piecolors[idx]; return val; } );

      const mpa = datapoints.filter( p => p.beacontype === "page view" )[0];
      mpa.color = piecolors[0];
      mpa.beacontype = "MPA";

      const spah = datapoints.filter( p => p.beacontype === "spa" )[0];
      spah.color = piecolors[1];
      spah.beacontype = "SPA (hard)";

      const spas = datapoints.filter( p => p.beacontype === "spa hard" )[0];
      spas.color = piecolors[2];
      spas.beacontype = "SPA (soft)";

      // datapoints.filter( p => p.beacontype === "bfcache" )[0].color = TimeSeries.Colors.RUMARCHIVE_BLUE_2;

      options.chartId = chartId;
      options.name = chartName;
      options.datapoints = datapoints;
      options.datapointFieldname = valueKey;
      options.queryURL = Constants.getQueryURL(queryName);

      Donuts.fromData( metricFieldName, options );
    }

    renderBeaconTypePiechart("desktop", "spa_desktop", "MPA vs SPA (Desktop)");
    renderBeaconTypePiechart("mobile", "spa_mobile", "MPA vs SPA (Mobile)");

</script>
